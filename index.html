<!DOCTYPE html> <html xmlns="http://www.w3.org/1999/xhtml"> <head> <meta charset="utf-8"/> <title>Parachute</title> <meta name="viewport" content="width=device-width"/> <meta name="description" content="An extensible and cross-compatible testing framework."/> <meta name="author" content="Nicolas Hafner &lt;shinmera@tymoon.eu&gt;"/> <style type="text/css"> body{
          max-width: 1024px;
          margin: 0 auto 0 auto;
          font-family: sans-serif;
          color: #333333;
          font-size: 14pt;
          padding: 5px;
      }

      body>header{
          display:flex;
          align-items: center;
          justify-content: center;
          flex-direction: column;
          max-width: 100%;
      }

      img{
          max-width: 100%;
          max-height: 100%;
      }

      code{
          font-family: Consolas, Inconsolata, monospace;
      }

      a{
          text-decoration: none;
          color: #0055AA;
      }

      #documentation{
          text-align: justify;
      }

      #documentation pre{
          margin-left: 20px;
          overflow: auto;
      }

      #symbol-index>ul{
          list-style: none;
          padding: 0;
      }
      #symbol-index .package>ul{
          list-style: none;
          padding: 0 0 0 10px;
      }
      #symbol-index .package .nicknames{
          font-weight: normal;
      }
      #symbol-index .package h4{
          display: inline-block;
          margin: 0;
      }
      #symbol-index .package article{
          margin: 0 0 15px 0;
      }
      #symbol-index .package article header{
          font-size: 1.2em;
          font-weight: normal;
      }
      #symbol-index .package .name{
          margin-right: 5px;
      }
      #symbol-index .package .docstring{
          margin: 0 0 0 15px;
          white-space: pre-wrap;
          font-size: 12pt;
      }

      @media (max-width: 800px){
          body{font-size: 12pt;}
      } </style> </head> <body> <header> <h1><img alt="parachute" src="parachute-logo.png"/></h1> <span class="version">1.0.0</span> <p class="description">An extensible and cross-compatible testing framework.</p> </header> <main> <article id="documentation">  <div><h2>About parachute</h2> <p>Parachute is a simple-to-use and extensible testing framework.</p> <h2>How To</h2> <p>In Parachute, things are organised as a bunch of named tests within a package. Each test can contain a bunch of test forms that make up its body. By default <code><a href="#PARACHUTE:TRUE">true</a></code>, <code><a href="#PARACHUTE:FALSE">false</a></code>, <code><a href="#PARACHUTE:FAIL">fail</a></code>, <code><a href="#PARACHUTE:IS">is</a></code>, <code><a href="#PARACHUTE:ISNT">isnt</a></code>, <code><a href="#PARACHUTE:OF-TYPE">of-type</a></code>, and <code><a href="#PARACHUTE:FINISH">finish</a></code> are provided as test forms.</p> <pre><code>(<a href="#PARACHUTE:DEFINE-TEST">define-test</a> numbers
  (<a href="#PARACHUTE:OF-TYPE">of-type</a> integer 5)
  (<a href="#PARACHUTE:TRUE">true</a> (<a href="http://l1sp.org/cl/numberp">numberp</a> 2/3))
  (<a href="#PARACHUTE:FALSE">false</a> (<a href="http://l1sp.org/cl/numberp">numberp</a> :keyword)))
</code></pre> <p>The name of a test can be either a symbol or a string, though both get coerced to a string internally.</p> <pre><code>(<a href="#PARACHUTE:DEFINE-TEST">define-test</a> &quot;A more descriptive name, perhaps&quot;)
</code></pre> <p>Tests can have dependencies in order to ensure that you don't get cascade failures. If a test's dependency fails, it is automatically skipped.</p> <pre><code>(<a href="#PARACHUTE:DEFINE-TEST">define-test</a> equality
  :depends-on (numbers)
  (<a href="#PARACHUTE:IS">is</a> = 0 1))             ; Bogus

(<a href="#PARACHUTE:DEFINE-TEST">define-test</a> arithmetic
  :depends-on (equality)
  (<a href="#PARACHUTE:IS">is</a> = 5 (<a href="http://l1sp.org/cl/+">+</a> 2 3)))
</code></pre> <p>Dependencies can also be logically combined if you require more complicated dependency logic.</p> <pre><code>(<a href="#PARACHUTE:DEFINE-TEST">define-test</a> unexpected-failure-backup-test
  :depends-on (:and equality (:not arithmetic))
  (<a href="#PARACHUTE:OF-TYPE">of-type</a> number (<a href="http://l1sp.org/cl/+">+</a> 2 3))) ; Maybe everything broke?
</code></pre> <p>Often times it also makes sense to organise tests according to a hierarchy. For example you could have tests that reflect your type hierarchy, or other kind of structure within your system. You can also use this to create simple test suites.</p> <pre><code>(<a href="#PARACHUTE:DEFINE-TEST">define-test</a> suite)

(<a href="#PARACHUTE:DEFINE-TEST">define-test</a> test-a
  :parent suite
  ...)

(<a href="#PARACHUTE:DEFINE-TEST">define-test</a> (suite test-b)
  ...)

(<a href="#PARACHUTE:DEFINE-TEST">define-test</a> other-suite
  ...
  (<a href="#PARACHUTE:DEFINE-TEST">define-test</a> other-test
     ...))
</code></pre> <p>Sometimes it is then useful to skip children if you know that they are either faulty or incomplete and shouldn't yet be tested as part of the greater scheme.</p> <pre><code>(<a href="#PARACHUTE:DEFINE-TEST">define-test</a> suite
  :skip (test-a))
</code></pre> <p>If you need to skip individual test forms rather than a whole test, you can use the <code><a href="#PARACHUTE:SKIP">skip</a></code> form.</p> <pre><code>(<a href="#PARACHUTE:DEFINE-TEST">define-test</a> stuff
  (<a href="#PARACHUTE:TRUE">true</a> :pass)
  (<a href="#PARACHUTE:SKIP">skip</a> &quot;Not ready yet&quot;
    (<a href="#PARACHUTE:IS">is</a> = 5 (some-unimplemented-function 10))))
</code></pre> <p>In order to ensure that there is no accidental sequential dependency between test forms or children, you can use the <code>:serial NIL</code> option, which will shuffle the test forms and children each time before evaluating them.</p> <pre><code>(<a href="#PARACHUTE:DEFINE-TEST">define-test</a> random
  :serial NIL
  (<a href="#PARACHUTE:TRUE">true</a> 1)
  (<a href="#PARACHUTE:TRUE">true</a> 2)
  (<a href="#PARACHUTE:TRUE">true</a> 3)
  (<a href="#PARACHUTE:TRUE">true</a> 4)
  (<a href="#PARACHUTE:TRUE">true</a> 5))
</code></pre> <p>If you need to wrap your test forms in some kind of environment, then the shuffling won't work automatically. However, you can fix this by wrapping the forms in a <code><a href="#PARACHUTE:WITH-SHUFFLING">with-shuffling</a></code> form.</p> <pre><code>(<a href="#PARACHUTE:DEFINE-TEST">define-test</a> random-2
  (<a href="http://l1sp.org/cl/let">let</a> ((a 0))
    (<a href="#PARACHUTE:WITH-SHUFFLING">with-shuffling</a>
      (<a href="#PARACHUTE:IS">is</a> = 1 (<a href="http://l1sp.org/cl/incf">incf</a> a))
      (<a href="#PARACHUTE:IS">is</a> = 2 (<a href="http://l1sp.org/cl/incf">incf</a> a))
      (<a href="#PARACHUTE:IS">is</a> = 3 (<a href="http://l1sp.org/cl/incf">incf</a> a)))))
</code></pre> <p>In case your code will cause changes to the global environment, you probably will want to fix it in place to make sure they are restored to their former values after the test completes. Parachute allows you to automatically fix variables, functions, and macros in place.</p> <pre><code>(<a href="#PARACHUTE:DEFINE-TEST">define-test</a> float-format
  :fix (<a href="http://l1sp.org/cl/*read-default-float-format*">*read-default-float-format*</a>)
  (<a href="#PARACHUTE:OF-TYPE">of-type</a> single-float (<a href="http://l1sp.org/cl/read-from-string">read-from-string</a> &quot;0.5&quot;))
  (<a href="http://l1sp.org/cl/setf">setf</a> *read-default-float-format* 'double-float)
  (<a href="#PARACHUTE:OF-TYPE">of-type</a> double-float (<a href="http://l1sp.org/cl/read-from-string">read-from-string</a> &quot;0.5&quot;)))
</code></pre> <p>You can also tell it to hold all the symbols accessible to a certain package in place by giving it a package designator as a keyword, gensym, or string. Using <code><a href="#PARACHUTE:WITH-FIXTURES">with-fixtures</a></code>, this can also be done locally. It expects an evaluated list of fixtures.</p> <pre><code>(<a href="#PARACHUTE:DEFINE-TEST">define-test</a> float-format2
  (<a href="#PARACHUTE:WITH-FIXTURES">with-fixtures</a> '(<a href="http://l1sp.org/cl/*read-default-float-format*">*read-default-float-format*</a>)
    (<a href="http://l1sp.org/cl/setf">setf</a> *read-default-float-format* 'double-float)
    (<a href="#PARACHUTE:OF-TYPE">of-type</a> double-float (<a href="http://l1sp.org/cl/read-from-string">read-from-string</a> &quot;0.5&quot;)))
  (<a href="#PARACHUTE:OF-TYPE">of-type</a> single-float (<a href="http://l1sp.org/cl/read-from-string">read-from-string</a> &quot;0.5&quot;)))
</code></pre> <p>If you have a user-defined binding to a symbol you can also make the fixture system aware of it so that it'll capture the bindings automatically.</p> <pre><code>(<a href="#PARACHUTE:DEFINE-FIXTURE-CAPTURE">define-fixture-capture</a> my-binding (<a href="http://l1sp.org/cl/symbol">symbol</a>)
  (<a href="http://l1sp.org/cl/when">when</a> (my-binding-bound-p symbol)
    (<a href="http://l1sp.org/cl/values">values</a> (my-binding-value symbol) T)))

(<a href="#PARACHUTE:DEFINE-FIXTURE-RESTORE">define-fixture-restore</a> my-binding (<a href="http://l1sp.org/cl/symbol">symbol</a> value)
  (<a href="http://l1sp.org/cl/setf">setf</a> (my-binding-value symbol) value))
</code></pre> <p>Sometimes the compiler will already complain for some tests that you expect to fail, for instance when the type inference is too good. In that case you can force Parachute to only compile the test forms when the test is evaluated. This is also useful when you're continuously working on macros and the like and don't want to recompile the test all the time. Parachute does not do this by default in order to give you useful compiler feedback in case you mess up writing your tests, and in order to avoid having to pay the time to invoke the compiler when it usually isn't necessary. Note that the compilation of the forms will be factored into your timing results.</p> <pre><code>(<a href="#PARACHUTE:DEFINE-TEST">define-test</a> compare-numbers
  :compile-at :execute
  (<a href="#PARACHUTE:FAIL">fail</a> (<a href="http://l1sp.org/cl/=">=</a> :5 5)))
</code></pre> <p>Finally, Parachute also allows you to enforce timing constraints on tests to make sure that they complete within a specified limit.</p> <pre><code>(<a href="#PARACHUTE:DEFINE-TEST">define-test</a> too-slow
  :time-limit 0.5
  (<a href="http://l1sp.org/cl/sleep">sleep</a> 1))
</code></pre> <p>Tests are run under a <code><a href="#PARACHUTE:REPORT">report</a></code> context, which gathers a bunch of <code><a href="#PARACHUTE:RESULT">result</a></code> objects that are generated as part of the evaluation and is responsible for presenting them to the user in some hopefully useful manner. The standard report is <code><a href="#PARACHUTE:PLAIN">plain</a></code>, which reports things as text to the REPL.</p> <pre><code>(<a href="#PARACHUTE:TEST">test</a> 'arithmetic)
</code></pre> <p><img src="https://filebox.tymoon.eu/file/TVRFMU5RPT0=" alt="plain-test-result"/></p> <p>There are two more report types included in the standard distribution, namely <code><a href="#PARACHUTE:QUIET">quiet</a></code> and <code><a href="#PARACHUTE:INTERACTIVE">interactive</a></code>. The former should not produce any output or user-interaction whatseover.</p> <pre><code>(<a href="#PARACHUTE:TEST">test</a> 'arithmethic :report 'quiet)
</code></pre> <p><img src="https://filebox.tymoon.eu/file/TVRFMU5BPT0=" alt="quiet-test-result"/></p> <p>The latter on the other hand will present you the debugger with a handful of useful restarts whenever a test fails. This allows you to iteratively and dynamically develop and refine tests.</p> <pre><code>(<a href="#PARACHUTE:TEST">test</a> 'arithmetic :report 'interactive)
</code></pre> <p><img src="https://filebox.tymoon.eu/file/TVRFMU5nPT0=" alt="interactive-test-result"/></p> <p>And that should cover most of it. Parachute does not have any fancy ASDF integration, however I don't believe any is needed anyway. Simply modifying your main system and test system as follows should be sufficient.</p> <pre><code>(asdf:defsystem main-system
  ...
  :in-order-to ((asdf:test-op (asdf:test-op :test-system))))

(asdf:defsystem test-system
  ...
  :perform (asdf:test-op (op c) (uiop:symbol-call :parachute :test :test-system)))
</code></pre> <p>This should allow you to run the tests via ASDF like so: <code>(asdf:test-system :main-system)</code>.</p> <h2>Compatibility Layers</h2> <p>Parachute offers &quot;zero-cost switching&quot; by implementing basic compatibility layers that simulate another test framework's syntax and behaviour. This allows you to switch over from another test framework hopefully without having to change a single test in your suite.</p> <p>Usually the only thing you need to do to get this done is change the name of the framework in your test system dependencies to one prefixed with <code>parachute-</code>. However, since there's so many test frameworks, and each layer requires quite a bit of work and investigation, only some are supported.</p> <p>The layers only mirror the public API of the test frameworks and leave out any extension mechanisms. They also do not attempt to mirror the output format or interaction method by which the other frameworks functioned, as there would be little point to mirroring them exactly.</p> <p>Compatibility layers exist for:</p> <ul> <li><a href="https://common-lisp.net/project/fiveam/">5am</a></li> <li><a href="https://github.com/OdonataResearchLLC/lisp-unit">lisp-unit</a></li> <li><a href="https://github.com/fukamachi/prove">prove</a><br/> Note: make sure to both change the <code>:depends-on</code> and <code>:defsystem-depends-on</code> to <code>parachute-prove</code> if you happen to use the ASDF extension.</li> </ul> <h2>Extending Parachute</h2> <h3>Test and Result Evaluation</h3> <p>Parachute follows its own evaluation semantics in order to run tests. Primarily this means that most everything goes through one central function called <code><a href="#PARACHUTE:EVAL-IN-CONTEXT">eval-in-context</a></code>. This functions allows you to customise evaluation based on both what the context is, and what the object being &quot;evaluated&quot; is.</p> <p>Usually the context is a report object, but other situations might also be conceived. Either way, it is your responsibility to add methods to this function when you add a new <code><a href="#PARACHUTE:RESULT">result</a></code> type, some kind of <code><a href="#PARACHUTE:TEST">test</a></code> subclass, or a new <code><a href="#PARACHUTE:REPORT">report</a></code> type that you want to customise according to your desired behaviour.</p> <p>The evaluation of results is decoupled from the context and reports in the sense that their behaviour does not, by default, depend on it. At the most basic, the <code><a href="#PARACHUTE:RESULT">result</a></code> class defines a single <code>:around</code> method that takes care of recording the <code><a href="#PARACHUTE:DURATION">duration</a></code> of the test evaluation, setting a default <code><a href="#PARACHUTE:STATUS">status</a></code> after finishing without errors, and skipping evaluation if the status is already set to something other than <code>:unknown</code>.</p> <p>Next we have a result object that is interesting for anything that actually produces direct test results-- <code><a href="#PARACHUTE:VALUE-RESULT">value-result</a></code>. Upon evaluation, if the <code><a href="#PARACHUTE:VALUE">value</a></code> slot is not yet bound, it calls its <code>body</code> function and stores the return value thereof in the <code><a href="#PARACHUTE:VALUE">value</a></code> slot.</p> <p>However, the result type that is actually used for all standard test forms is the <code><a href="#PARACHUTE:COMPARISON-RESULT">comparison-result</a></code>. This also takes a comparator function and an expected result to compare against upon completion of the test. If the results match, then the test status is set to <code>:passed</code>, otherwise to <code>:failed</code>.</p> <p>Since Parachute allows for a hierarchy in your tests, there have to be aggregate results as well, and indeed there are. Two of them, actually. First is the base case, namely <code><a href="#PARACHUTE:PARENT-RESULT">parent-result</a></code> which does two things on evaluation: one, it binds <code>*parent*</code> to itself to allow other results to register themselves upon construction, and two it sets its status to <code>:failed</code> if any of the <code><a href="#PARACHUTE:CHILDREN">children</a></code> have failed.</p> <p>Finally we have the <code><a href="#PARACHUTE:TEST-RESULT">test-result</a></code> which takes care of properly evaluating an actual <code><a href="#PARACHUTE:TEST">test</a></code> object. What this means is to evaluate all <code><a href="#PARACHUTE:DEPENDENCIES">dependencies</a></code> before anything else happens, and to check the time limit after everything else has happened. If the time limit has exceeded, set the <code><a href="#PARACHUTE:DESCRIPTION">description</a></code> accordingly and mark the result as <code>:failed</code>. For its main <code><a href="#PARACHUTE:EVAL-IN-CONTEXT">eval-in-context</a></code> method however it checks whether any of the dependencies have failed, and if so, mark itself as <code>:skipped</code>. Otherwise it calls <code><a href="#PARACHUTE:EVAL-IN-CONTEXT">eval-in-context</a></code> on the actual test object. Finally it evaluates every one of the <code><a href="#PARACHUTE:CHILDREN">children</a></code> of the test, making sure to mark the ones in the <code><a href="#PARACHUTE:SKIPPED-CHILDREN">skipped-children</a></code> list as <code>:skipped</code> beforehand.</p> <p>The default evaluation procedure for a test itself is to simply call all the functions in the <code><a href="#PARACHUTE:TESTS">tests</a></code> list in a <code><a href="#PARACHUTE:WITH-FIXTURES">with-fixtures</a></code> environment.</p> <p>And that describes the semantics of default test procedures. Actual test forms like <code><a href="#PARACHUTE:IS">is</a></code> are created through macros that emit an <code>(<a href="#PARACHUTE:EVAL-IN-CONTEXT">eval-in-context</a> *context* (<a href="http://l1sp.org/cl/make-instance">make-instance</a> 'comparison-result ...))</code> form. The <code><a href="#PARACHUTE:*CONTEXT*">*context*</a></code> object is automatically bound to the context object on call of <code><a href="#PARACHUTE:EVAL-IN-CONTEXT">eval-in-context</a></code> and thus always refers to the current context object. This allows results to be evaluated even from within opaque parts like user-defined functions.</p> <h3>Report Generation</h3> <p>Finally we come to the question of how to generate a report and interact with the evaluation process. The most primitive idea for a report is one that doesn't do anything at all, except for perhaps catching stray errors. This is implemented by the <code><a href="#PARACHUTE:QUIET">quiet</a></code> report object, which only has a single <code><a href="#PARACHUTE:EVAL-IN-CONTEXT">eval-in-context</a></code> <code>:around</code> method that has a handler-case around the rest.</p> <p>It should be possible to get any kind of reporting behaviour you want by adding methods that specialise on your report object to <code><a href="#PARACHUTE:EVAL-IN-CONTEXT">eval-in-context</a></code>. For the simple case where you want something that prints to the REPL but has a different style than the preset <code><a href="#PARACHUTE:PLAIN">plain</a></code> report, you can simply subclass that and specialise on the <code><a href="#PARACHUTE:REPORT-ON">report-on</a></code> and <code><a href="#PARACHUTE:SUMMARIZE">summarize</a></code> functions that then produce the output you want.</p> <p>Since you can control pretty much every aspect of evaluation rather closely, very different behaviours and recovery mechanisms are also possible to achieve. One final aspect to note is <code><a href="#PARACHUTE:RESULT-FOR-TESTABLE">result-for-testable</a></code>, which should return an appropriate result object for the given testable. This should only return fresh result objects if no result is already known for the testable in the given context. The standard tests provide for this, however they only ever return a standard <code><a href="#PARACHUTE:TEST-RESULT">test-result</a></code> instance. If you need to customise the behaviour of the evaluation for that part, it would be a wise idea to subclass <code><a href="#PARACHUTE:TEST-RESULT">test-result</a></code> and make sure to return instances thereof from <code><a href="#PARACHUTE:RESULT-FOR-TESTABLE">result-for-testable</a></code> for your report.</p> <p>Finally it should be noted that if you happen to create new <code><a href="#PARACHUTE:RESULT">result</a></code> types that you might want to run using the default reports, you should add methods to <code><a href="#PARACHUTE:FORMAT-RESULT">format-result</a></code> that specialise on the keywords <code>:oneline</code> and <code>:extensive</code> for the type. These should return a string containing an appropriate description of the test in one line or extensively, respectively. This will allow you to customise how things look to some degree without having to create a new report object entirely.</p> </div>  </article> <article id="copyright">  <h2>Copyright</h2> <span>parachute</span> is licensed under the <span><a href="https://tldrlegal.com/search?q=Artistic">Artistic</a></span> license.  Â© <span>Nicolas Hafner &lt;shinmera@tymoon.eu&gt;</span> .  This library can be obtained on <a href="https://github.com/Shinmera/parachute">https://github.com/Shinmera/parachute</a>.  </article>  <article id="symbol-index"> <h2>Package Index</h2> <ul><li class="package"> <h3> <a name="PARACHUTE" href="#PARACHUTE">PARACHUTE</a> <span class="nicknames">(ORG.SHIRAKUMO.PARACHUTE)</span> </h3> <ul><li> <a name="PARACHUTE:*CONTEXT*"> </a> <article> <header class="special"> <span class="type">special</span>  <h4 class="name"><code><a href="#PARACHUTE:*CONTEXT*">*CONTEXT*</a></code></h4>  </header> <pre class="docstring">Variable storing the current context of the evaluation.

While EVAL-IN-CONTEXT already carries the context as an argument,
in certain situations like when opaque functions are evaluated, testers
within the execution context must be able to access the context object
in order to evaluate properly.</pre> </article> </li><li> <a name="PARACHUTE:*FIXTURE-CAPTURES*"> </a> <article> <header class="special"> <span class="type">special</span>  <h4 class="name"><code><a href="#PARACHUTE:*FIXTURE-CAPTURES*">*FIXTURE-CAPTURES*</a></code></h4>  </header> <pre class="docstring">A map of names to fixture capture functions.

See DEFINE-FIXTURE-CAPTURE</pre> </article> </li><li> <a name="PARACHUTE:*FIXTURE-RESTORES*"> </a> <article> <header class="special"> <span class="type">special</span>  <h4 class="name"><code><a href="#PARACHUTE:*FIXTURE-RESTORES*">*FIXTURE-RESTORES*</a></code></h4>  </header> <pre class="docstring">A map of names to fixture restore functions.

See DEFINE-FIXTURE-RESTORE</pre> </article> </li><li> <a name="PARACHUTE:COMPARISON-RESULT"> </a> <article> <header class="class"> <span class="type">class</span>  <h4 class="name"><code><a href="#PARACHUTE:COMPARISON-RESULT">COMPARISON-RESULT</a></code></h4>  </header> <pre class="docstring">A result that compares against an expected value by some kind of comparator.

This result sets its status based on the boolean return value of a test
of its value against an expected, preset value.

See VALUE-FORM
See EXPECTED
See COMPARISON
See COMPARISON-GEQ
See VALUE-RESULT</pre> </article> </li><li> <a name="PARACHUTE:FINISHING-RESULT"> </a> <article> <header class="class"> <span class="type">class</span>  <h4 class="name"><code><a href="#PARACHUTE:FINISHING-RESULT">FINISHING-RESULT</a></code></h4>  </header> <pre class="docstring">A result that only passes if its evaluation proceeds without escaping.

See VALUE-RESULT</pre> </article> </li><li> <a name="PARACHUTE:INTERACTIVE"> </a> <article> <header class="class"> <span class="type">class</span>  <h4 class="name"><code><a href="#PARACHUTE:INTERACTIVE">INTERACTIVE</a></code></h4>  </header> <pre class="docstring">An interactive test report that shows the debugger on every failure, with restarts that allow you to decide what to do next.

See REPORT</pre> </article> </li><li> <a name="PARACHUTE:PARENT-RESULT"> </a> <article> <header class="class"> <span class="type">class</span>  <h4 class="name"><code><a href="#PARACHUTE:PARENT-RESULT">PARENT-RESULT</a></code></h4>  </header> <pre class="docstring">A result that does not directly perform a test, but rather serves as an aggregate for multiple tests.

This result will set its status to :FAILED automatically if it notices that
after evaluation one or more of its child results have the status :FAILED.

See RESULTS
See RESULT
See FIND-CHILD-RESULT
See RESULTS-WITH-STATUS
See ADD-RESULT</pre> </article> </li><li> <a name="PARACHUTE:PLAIN"> </a> <article> <header class="class"> <span class="type">class</span>  <h4 class="name"><code><a href="#PARACHUTE:PLAIN">PLAIN</a></code></h4>  </header> <pre class="docstring">A plain-text report that prints test results as they go by as well as a summary of the failures at the end.

See REPORT
See OUTPUT
See REPORT-ON</pre> </article> </li><li> <a name="PARACHUTE:QUIET"> </a> <article> <header class="class"> <span class="type">class</span>  <h4 class="name"><code><a href="#PARACHUTE:QUIET">QUIET</a></code></h4>  </header> <pre class="docstring">A quiet report that doesn't report nor do anything special.

Simply returns the report object on SUMMARIZE.

See REPORT</pre> </article> </li><li> <a name="PARACHUTE:REPORT"> </a> <article> <header class="class"> <span class="type">class</span>  <h4 class="name"><code><a href="#PARACHUTE:REPORT">REPORT</a></code></h4>  </header> <pre class="docstring">Base class for all report objects.

Reports are responsible for gathering and representing the
results of a test evaluation. The manner in which the results are
presented to the user is up to the test in question.

See PARENT-RESULT
See SUMMARIZE</pre> </article> </li><li> <a name="PARACHUTE:RESULT"> </a> <article> <header class="class"> <span class="type">class</span>  <h4 class="name"><code><a href="#PARACHUTE:RESULT">RESULT</a></code></h4>  </header> <pre class="docstring">Base container object for test results of any kind.

A result always has:
  EXPRESSION  -- An expression describing what this result is about.
  STATUS      -- One of :UNKNOWN :FAILED :PASSED :SKIPPED.
  DURATION    -- The duration (in seconds) the evaluation took, or NIL.
  DESCRIPTION -- A string describing the result, or NIL.

See EXPRESSION
See STATUS
See DURATION
See DESCRIPTION</pre> </article> </li><li> <a name="PARACHUTE:TEST"> </a> <article> <header class="class"> <span class="type">class</span>  <h4 class="name"><code><a href="#PARACHUTE:TEST">TEST</a></code></h4>  </header> <pre class="docstring">Container for test collections.

Manages all the data that ties different collections together
and manages the various options you might want to have for tests.

Note that merely initializing a test instance will not register it
to be found by FIND-TEST. It will also not tie it in with the rest
of the tests. An error will be signalled, if a parent is designated
that does not exist, and warnings will be signalled if dependencies
are designated that do not exist.

In order for the test to be tied in and registered to be findable,
use (SETF (FIND-TEST name home) test). In order to remove it, simply
use REMOVE-TEST.

See NAME
See HOME
See DESCRIPTION
See PARENT
See CHILDREN
See DEPENDENCIES
See REFERENCED-DEPENDENCIES
See FIXTURES
See TIME-LIMIT
See SKIPPED-CHILDREN
See REFERENCED-SKIPS
See TESTS
See SERIAL
See FIND-TEST
See REMOVE-TEST
See DEFINE-TEST</pre> </article> </li><li> <a name="PARACHUTE:TEST-RESULT"> </a> <article> <header class="class"> <span class="type">class</span>  <h4 class="name"><code><a href="#PARACHUTE:TEST-RESULT">TEST-RESULT</a></code></h4>  </header> <pre class="docstring">A result object for tests.

This takes care of properly evaluating the test by following these steps:
1. Run all tests in the test's DEPENDENCIES as per EVAL-DEPENDENCY-COMBINATION
2. Check that all dependencies have a :PASSED status as per the dependency
   combination by running CHECK-DEPENDENCY-COMBINATION
3. For each child in the test's CHILDREN
   create a result by RESULT-FOR-TESTABLE
   if the child is part of the test's SKIPPED-CHILDREN
   mark its result as :SKIPPED and EVAL-IN-CONTEXT it.
   Otherwise EVAL-IN-CONTEXT the child's result directly.

The methods implemented by PARENT-RESULT and RESULT will in turn
take care to implement proper status setting and avoiding duplicate
evaluation.

See PARENT-RESULT
See EVAL-DEPENDENCY-COMBINATION
See CHECK-DEPENDENCY-COMBINATION</pre> </article> </li><li> <a name="PARACHUTE:VALUE-RESULT"> </a> <article> <header class="class"> <span class="type">class</span>  <h4 class="name"><code><a href="#PARACHUTE:VALUE-RESULT">VALUE-RESULT</a></code></h4>  </header> <pre class="docstring">A result that carries some kind of test result value.

Typically the VALUE slot is only set once the result is evaluated. Note that
if the VALUE slot is bound at the time that the result is evaluated, the
BODY will not be run.

See BODY
See VALUE
See RESULT</pre> </article> </li><li> <a name="PARACHUTE:CHILDREN"> </a> <article> <header class="accessor"> <span class="type">accessor</span>  <code>(</code><h4 class="name"><code><a href="#PARACHUTE:CHILDREN">CHILDREN</a></code></h4> <code class="qualifiers"></code> <code class="arguments">OBJECT</code><code>)</code>  </header> <pre class="docstring">The list of child test instances.

Note that the return value of this will be shuffled randomly if the test is
marked as non-serial. Child tests will be evaluated after the test itself.

See SERIAL
See TEST</pre> </article> </li><li> <a name="PARACHUTE:COMPARISON"> </a> <article> <header class="accessor"> <span class="type">accessor</span>  <code>(</code><h4 class="name"><code><a href="#PARACHUTE:COMPARISON">COMPARISON</a></code></h4> <code class="qualifiers"></code> <code class="arguments">OBJECT</code><code>)</code>  </header> <pre class="docstring">The comparison function designator that compares the expected and actual values of the test.

See COMPARISON-RESULT</pre> </article> </li><li> <a name="PARACHUTE:COMPARISON-GEQ"> </a> <article> <header class="accessor"> <span class="type">accessor</span>  <code>(</code><h4 class="name"><code><a href="#PARACHUTE:COMPARISON-GEQ">COMPARISON-GEQ</a></code></h4> <code class="qualifiers"></code> <code class="arguments">OBJECT</code><code>)</code>  </header> <pre class="docstring">The value to which the comparison result must be GEQ to.

Defaults to T.

See COMPARISON-RESULT
See GEQ</pre> </article> </li><li> <a name="PARACHUTE:DESCRIPTION"> </a> <article> <header class="accessor"> <span class="type">accessor</span>  <code>(</code><h4 class="name"><code><a href="#PARACHUTE:DESCRIPTION">DESCRIPTION</a></code></h4> <code class="qualifiers"></code> <code class="arguments">OBJECT</code><code>)</code>  </header> <pre class="docstring">The description of what the test/result is about as a string or NIL.

See RESULT
See TEST</pre> </article> </li><li> <a name="PARACHUTE:DURATION"> </a> <article> <header class="accessor"> <span class="type">accessor</span>  <code>(</code><h4 class="name"><code><a href="#PARACHUTE:DURATION">DURATION</a></code></h4> <code class="qualifiers"></code> <code class="arguments">OBJECT</code><code>)</code>  </header> <pre class="docstring">The duration the evaluation of the result object took in seconds or NIL.

This is automatically recorded in standard methods for EVAL-IN-CONTEXT.
The value may be NIL if the test has not yet been evaluated at all.

See RESULT</pre> </article> </li><li> <a name="PARACHUTE:EXPECTED"> </a> <article> <header class="accessor"> <span class="type">accessor</span>  <code>(</code><h4 class="name"><code><a href="#PARACHUTE:EXPECTED">EXPECTED</a></code></h4> <code class="qualifiers"></code> <code class="arguments">OBJECT</code><code>)</code>  </header> <pre class="docstring">A value that should be equal (under some predicate) to what the test evaluates to.

See COMPARISON-RESULT</pre> </article> </li><li> <a name="PARACHUTE:EXPRESSION"> </a> <article> <header class="accessor"> <span class="type">accessor</span>  <code>(</code><h4 class="name"><code><a href="#PARACHUTE:EXPRESSION">EXPRESSION</a></code></h4> <code class="qualifiers"></code> <code class="arguments">OBJECT</code><code>)</code>  </header> <pre class="docstring">The expression that the result object is about.

See RESULT</pre> </article> </li><li> <a name="PARACHUTE:FIND-TEST"> </a> <article> <header class="accessor"> <span class="type">accessor</span>  <code>(</code><h4 class="name"><code><a href="#PARACHUTE:FIND-TEST">FIND-TEST</a></code></h4> <code class="qualifiers"></code> <code class="arguments">NAME &amp;OPTIONAL PACKAGE-ISH</code><code>)</code>  </header> <pre class="docstring">Finds the test by name if possible.

If the name is a symbol, the package defaults to the symbol's package.
If the name is a string, the package defaults to *PACKAGE*.
If no explicit package has been given and no test has been found, the
search is automatically retried with the package set to *PACKAGE*. This
should avoid confusion in the case of imported symbols and tests defined
under the local package.

This function can also be used as a place in order to register a test.
When a test is set, the preexisting test if any is first removed by
REMOVE-TEST. This ensures that potentially removed options need to be
properly updated within other affected tests. After that, the test is
added to the list of children within its parent, if one is set. Finally
the test is registered within the test index.

See REMOVE-TEST
See *TEST-INDEX*</pre> </article> </li><li> <a name="PARACHUTE:FIXTURES"> </a> <article> <header class="accessor"> <span class="type">accessor</span>  <code>(</code><h4 class="name"><code><a href="#PARACHUTE:FIXTURES">FIXTURES</a></code></h4> <code class="qualifiers"></code> <code class="arguments">OBJECT</code><code>)</code>  </header> <pre class="docstring">The list of fixed symbols or packages.

See WITH-FIXTURE
See TEST</pre> </article> </li><li> <a name="PARACHUTE:OUTPUT"> </a> <article> <header class="accessor"> <span class="type">accessor</span>  <code>(</code><h4 class="name"><code><a href="#PARACHUTE:OUTPUT">OUTPUT</a></code></h4> <code class="qualifiers"></code> <code class="arguments">OBJECT</code><code>)</code>  </header> <pre class="docstring">The stream that the PLAIN report outputs to during REPORT-ON and SUMMARIZE.

See PLAIN
See REPORT-ON
See SUMMARIZE</pre> </article> </li><li> <a name="PARACHUTE:PARENT"> </a> <article> <header class="accessor"> <span class="type">accessor</span>  <code>(</code><h4 class="name"><code><a href="#PARACHUTE:PARENT">PARENT</a></code></h4> <code class="qualifiers"></code> <code class="arguments">OBJECT</code><code>)</code>  </header> <pre class="docstring">The parent test object, if any.

If a test has a parent, then it must also itself be contained in the parent's
children list.

See TEST</pre> </article> </li><li> <a name="PARACHUTE:REFERENCED-DEPENDENCIES"> </a> <article> <header class="accessor"> <span class="type">accessor</span>  <code>(</code><h4 class="name"><code><a href="#PARACHUTE:REFERENCED-DEPENDENCIES">REFERENCED-DEPENDENCIES</a></code></h4> <code class="qualifiers"></code> <code class="arguments">OBJECT</code><code>)</code>  </header> <pre class="docstring">The logical combination of test designators that reference a dependant test.

DEPENDENCIES ::= (DEPENDENCY*) | (LOGOP DEPENDENCY*)
LOGOP        ::= :OR | :AND | :NOT
DEPENDENCY   ::= test-name | (home test-name) | DEPENDENCIES

See DEPENDENCIES
See TEST</pre> </article> </li><li> <a name="PARACHUTE:REFERENCED-SKIPS"> </a> <article> <header class="accessor"> <span class="type">accessor</span>  <code>(</code><h4 class="name"><code><a href="#PARACHUTE:REFERENCED-SKIPS">REFERENCED-SKIPS</a></code></h4> <code class="qualifiers"></code> <code class="arguments">OBJECT</code><code>)</code>  </header> <pre class="docstring">The list of test designators that reference a skipped test.

See SKIPPED-CHILDREN
See TEST</pre> </article> </li><li> <a name="PARACHUTE:RESULTS"> </a> <article> <header class="accessor"> <span class="type">accessor</span>  <code>(</code><h4 class="name"><code><a href="#PARACHUTE:RESULTS">RESULTS</a></code></h4> <code class="qualifiers"></code> <code class="arguments">OBJECT</code><code>)</code>  </header> <pre class="docstring">The vector of child results within the parent.

See PARENT-RESULT
See ADD-CHILD</pre> </article> </li><li> <a name="PARACHUTE:SERIAL"> </a> <article> <header class="accessor"> <span class="type">accessor</span>  <code>(</code><h4 class="name"><code><a href="#PARACHUTE:SERIAL">SERIAL</a></code></h4> <code class="qualifiers"></code> <code class="arguments">OBJECT</code><code>)</code>  </header> <pre class="docstring">Whether the tests and children should be evaluated in order, or randomly.

This affects the return values of TESTS and CHILDREN.

See CHILDREN
See TESTS
See TEST</pre> </article> </li><li> <a name="PARACHUTE:STATUS"> </a> <article> <header class="accessor"> <span class="type">accessor</span>  <code>(</code><h4 class="name"><code><a href="#PARACHUTE:STATUS">STATUS</a></code></h4> <code class="qualifiers"></code> <code class="arguments">OBJECT</code><code>)</code>  </header> <pre class="docstring">The status of the result object.

Should be one of :UNKNOWN :FAILED :PASSED :SKIPPED. By default after 
initialization the status is :UNKNOWN. The status is automatically 
changed to :PASSED if the result is still :UNKNOWN after EVAL-IN-CONTEXT
 completes.

See RESULT</pre> </article> </li><li> <a name="PARACHUTE:TESTS"> </a> <article> <header class="accessor"> <span class="type">accessor</span>  <code>(</code><h4 class="name"><code><a href="#PARACHUTE:TESTS">TESTS</a></code></h4> <code class="qualifiers"></code> <code class="arguments">OBJECT</code><code>)</code>  </header> <pre class="docstring">The list of functions to execute in order to actually perform the tests.

Note that the return value of this will be shuffled randomly if the test is
marked as non-serial.

See SERIAL
See TEST</pre> </article> </li><li> <a name="PARACHUTE:TIME-LIMIT"> </a> <article> <header class="accessor"> <span class="type">accessor</span>  <code>(</code><h4 class="name"><code><a href="#PARACHUTE:TIME-LIMIT">TIME-LIMIT</a></code></h4> <code class="qualifiers"></code> <code class="arguments">OBJECT</code><code>)</code>  </header> <pre class="docstring">The time limit of the test, if any.

In order for the test to succeed, the evaluation must succeed before
the time limit is reached. Otherwise the test is marked as having failed.

See TEST</pre> </article> </li><li> <a name="PARACHUTE:VALUE"> </a> <article> <header class="accessor"> <span class="type">accessor</span>  <code>(</code><h4 class="name"><code><a href="#PARACHUTE:VALUE">VALUE</a></code></h4> <code class="qualifiers"></code> <code class="arguments">OBJECT</code><code>)</code>  </header> <pre class="docstring">The value of the result object that is obtained by running its body.

See BODY
See VALUE-RESULT</pre> </article> </li><li> <a name="PARACHUTE:VALUE-FORM"> </a> <article> <header class="accessor"> <span class="type">accessor</span>  <code>(</code><h4 class="name"><code><a href="#PARACHUTE:VALUE-FORM">VALUE-FORM</a></code></h4> <code class="qualifiers"></code> <code class="arguments">OBJECT</code><code>)</code>  </header> <pre class="docstring">A literal representation of the form that produces the value for the test.

See COMPARISON-RESULT</pre> </article> </li><li> <a name="PARACHUTE:CALL-WITH-FIXTURES"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#PARACHUTE:CALL-WITH-FIXTURES">CALL-WITH-FIXTURES</a></code></h4> <code class="qualifiers"></code> <code class="arguments">FUNCTION FIXTURES</code><code>)</code>  </header> <pre class="docstring">Calls the function with the given list of fixtures.

This ensures that the values are stored before the function is
called and restored once the function is completed.

See CAPTURE-FIXTURES
See RESTORE-FIXTURES
See WITH-FIXTURE</pre> </article> </li><li> <a name="PARACHUTE:CAPTURE-FIXTURES"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#PARACHUTE:CAPTURE-FIXTURES">CAPTURE-FIXTURES</a></code></h4> <code class="qualifiers"></code> <code class="arguments">FIXTURE</code><code>)</code>  </header> <pre class="docstring">Returns a list of fixtures for the given kind.

If the given name is a symbol that is not a keyword and has a
package associated with it, then a list of a single fixture that
captures every appropriate binding for the symbol is returned.
Otherwise the name is interpreted as a package for which a list
of fixtures for every symbol accessible in the package is returned.

See RESTORE-FIXTURES
See PACKAGE-FIXTURES
See DEFINE-FIXTURE-CAPTURE</pre> </article> </li><li> <a name="PARACHUTE:PACKAGE-FIXTURES"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#PARACHUTE:PACKAGE-FIXTURES">PACKAGE-FIXTURES</a></code></h4> <code class="qualifiers"></code> <code class="arguments">NAME</code><code>)</code>  </header> <pre class="docstring">Returns a list of fixtures for all symbols accessible in the given package.</pre> </article> </li><li> <a name="PARACHUTE:PACKAGE-TESTS"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#PARACHUTE:PACKAGE-TESTS">PACKAGE-TESTS</a></code></h4> <code class="qualifiers"></code> <code class="arguments">PACKAGE</code><code>)</code>  </header> <pre class="docstring">Returns a list of all the tests defined in the given package.

Signals an error if the PACKAGE cannot be resolved to a package object.

See *TEST-INDEXES*</pre> </article> </li><li> <a name="PARACHUTE:REMOVE-TEST"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#PARACHUTE:REMOVE-TEST">REMOVE-TEST</a></code></h4> <code class="qualifiers"></code> <code class="arguments">NAME &amp;OPTIONAL PACKAGE-ISH</code><code>)</code>  </header> <pre class="docstring">Removes the test by name if possible.

When a test is removed, it is also automatically removed from its
parent's child list. However, weak references such as within a test's
dependencies cannot be updated as there is no backreference.

See FIND-TEST
See *TEST-INDEX*</pre> </article> </li><li> <a name="PARACHUTE:RESTORE-FIXTURES"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#PARACHUTE:RESTORE-FIXTURES">RESTORE-FIXTURES</a></code></h4> <code class="qualifiers"></code> <code class="arguments">FIXTURES</code><code>)</code>  </header> <pre class="docstring">Restores the bindings stored in the fixtures to their saved values.

See CAPTURE-FIXTURES
See DEFINE-FIXTURE-RESTORE</pre> </article> </li><li> <a name="PARACHUTE:TEST"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#PARACHUTE:TEST">TEST</a></code></h4> <code class="qualifiers"></code> <code class="arguments">DESIGNATOR &amp;REST ARGS &amp;KEY (REPORT 'PLAIN) &amp;ALLOW-OTHER-KEYS</code><code>)</code>  </header> <pre class="docstring">Run a test.

DESIGNATOR is resolved to a list of tests to run under a single
report. You can specify the report class by the REPORT keyword
argument. All other arguments are used as initargs for the REPORT
creation.

After the report has been created, each test is run via 
EVAL-IN-CONTEXT. Finally SUMMARIZE is called on the report.

See REPORT
See RESOLVE-TESTS
See EVAL-IN-CONTEXT
See SUMMARIZE</pre> </article> </li><li> <a name="PARACHUTE:DEPENDENCIES"> </a> <article> <header class="generic"> <span class="type">generic</span>  <code>(</code><h4 class="name"><code><a href="#PARACHUTE:DEPENDENCIES">DEPENDENCIES</a></code></h4> <code class="qualifiers"></code> <code class="arguments">TEST</code><code>)</code>  </header> <pre class="docstring">The logical combination of dependant tests.

DEPENDENCIES ::= (LOGOP DEPENDENCY*)
LOGOP        ::= :OR | :AND | :NOT
DEPENDENCY   ::= test-object | DEPENDENCIES

If a dependency is referenced that does not exist, an error is signalled.
Dependant tests must be evaluated before the test itself.

See REFERENCED-DEPENDENCIES
See CHECK-DEPENDENCY-COMBINATION
See EVAL-DEPENDENCY-COMBINATION
See RESOLVE-DEPENDENCY-COMBINATION
See TEST</pre> </article> </li><li> <a name="PARACHUTE:EVAL-IN-CONTEXT"> </a> <article> <header class="generic"> <span class="type">generic</span>  <code>(</code><h4 class="name"><code><a href="#PARACHUTE:EVAL-IN-CONTEXT">EVAL-IN-CONTEXT</a></code></h4> <code class="qualifiers"></code> <code class="arguments">CONTEXT TEST</code><code>)</code>  </header> <pre class="docstring">Evaluates the thing within the given context.

This may seem like a rather generic description. In specific, this is mostly
used in order to provide a customizable evaluation behaviour during the
evaluation of tests under a given report. Which is to say that usually the 
context will be some report object and the thing being tested some kind of
result or test instance.

See REPORT
See RESULT</pre> </article> </li><li> <a name="PARACHUTE:FIND-CHILD-RESULT"> </a> <article> <header class="generic"> <span class="type">generic</span>  <code>(</code><h4 class="name"><code><a href="#PARACHUTE:FIND-CHILD-RESULT">FIND-CHILD-RESULT</a></code></h4> <code class="qualifiers"></code> <code class="arguments">TEST RESULT</code><code>)</code>  </header> <pre class="docstring">Attempts to find the result object associated with the given test.

This simply tests by EQ against the EXPRESSION of each child within the result.

See PARENT-RESULT</pre> </article> </li><li> <a name="PARACHUTE:FORMAT-RESULT"> </a> <article> <header class="generic"> <span class="type">generic</span>  <code>(</code><h4 class="name"><code><a href="#PARACHUTE:FORMAT-RESULT">FORMAT-RESULT</a></code></h4> <code class="qualifiers"></code> <code class="arguments">RESULT TYPE</code><code>)</code>  </header> <pre class="docstring">Formats the result into the requested representation as a string.

The representation type can, by default, be either :ONELINE or :EXTENSIVE.

See RESULT</pre> </article> </li><li> <a name="PARACHUTE:HOME"> </a> <article> <header class="generic"> <span class="type">generic</span>  <code>(</code><h4 class="name"><code><a href="#PARACHUTE:HOME">HOME</a></code></h4> <code class="qualifiers"></code> <code class="arguments">OBJECT</code><code>)</code>  </header> <pre class="docstring">The home package of the test.

See TEST</pre> </article> </li><li> <a name="PARACHUTE:NAME"> </a> <article> <header class="generic"> <span class="type">generic</span>  <code>(</code><h4 class="name"><code><a href="#PARACHUTE:NAME">NAME</a></code></h4> <code class="qualifiers"></code> <code class="arguments">OBJECT</code><code>)</code>  </header> <pre class="docstring">The name of the test, which is always a string.

See TEST</pre> </article> </li><li> <a name="PARACHUTE:REPORT-ON"> </a> <article> <header class="generic"> <span class="type">generic</span>  <code>(</code><h4 class="name"><code><a href="#PARACHUTE:REPORT-ON">REPORT-ON</a></code></h4> <code class="qualifiers"></code> <code class="arguments">RESULT REPORT</code><code>)</code>  </header> <pre class="docstring">Causes the result to be printed to standard output under the formatting of the report.

See REPORT
See RESULT</pre> </article> </li><li> <a name="PARACHUTE:RESULT-FOR-TESTABLE"> </a> <article> <header class="generic"> <span class="type">generic</span>  <code>(</code><h4 class="name"><code><a href="#PARACHUTE:RESULT-FOR-TESTABLE">RESULT-FOR-TESTABLE</a></code></h4> <code class="qualifiers"></code> <code class="arguments">TEST CONTEXT</code><code>)</code>  </header> <pre class="docstring">Returns an appropriate RESULT instance for the given testable and context.

You should specialize this if you need special kinds of result types for your
report.

See RESULT</pre> </article> </li><li> <a name="PARACHUTE:RESULTS-WITH-STATUS"> </a> <article> <header class="generic"> <span class="type">generic</span>  <code>(</code><h4 class="name"><code><a href="#PARACHUTE:RESULTS-WITH-STATUS">RESULTS-WITH-STATUS</a></code></h4> <code class="qualifiers"></code> <code class="arguments">STATUS RESULT</code><code>)</code>  </header> <pre class="docstring">Returns a list of results that are a child of the result and have the requested status.

See PARENT-RESULT</pre> </article> </li><li> <a name="PARACHUTE:SKIPPED-CHILDREN"> </a> <article> <header class="generic"> <span class="type">generic</span>  <code>(</code><h4 class="name"><code><a href="#PARACHUTE:SKIPPED-CHILDREN">SKIPPED-CHILDREN</a></code></h4> <code class="qualifiers"></code> <code class="arguments">TEST</code><code>)</code>  </header> <pre class="docstring">The list of the children that should be skipped.

If a child is referenced that does not exist, an error is signalled.
If a child is within this list, it will not be evaluated after the test
and instead be marked as skipped automatically.

See REFERENCED-SKIPS
See TEST</pre> </article> </li><li> <a name="PARACHUTE:SUMMARIZE"> </a> <article> <header class="generic"> <span class="type">generic</span>  <code>(</code><h4 class="name"><code><a href="#PARACHUTE:SUMMARIZE">SUMMARIZE</a></code></h4> <code class="qualifiers"></code> <code class="arguments">REPORT</code><code>)</code>  </header> <pre class="docstring">Should cause the report to produce some kind of summary.

How this summary is presented and what is contained in it is up to
the report itself.

See REPORT.</pre> </article> </li><li> <a name="PARACHUTE:TESTS-WITH-STATUS"> </a> <article> <header class="generic"> <span class="type">generic</span>  <code>(</code><h4 class="name"><code><a href="#PARACHUTE:TESTS-WITH-STATUS">TESTS-WITH-STATUS</a></code></h4> <code class="qualifiers"></code> <code class="arguments">STATUS REPORT</code><code>)</code>  </header> <pre class="docstring">Returns a list of TEST objects that have been evaluated and whose reports have the requested status.

See REPORT
See RESULTS-WITH-STATUS</pre> </article> </li><li> <a name="PARACHUTE:DEFINE-FIXTURE-CAPTURE"> </a> <article> <header class="macro"> <span class="type">macro</span>  <code>(</code><h4 class="name"><code><a href="#PARACHUTE:DEFINE-FIXTURE-CAPTURE">DEFINE-FIXTURE-CAPTURE</a></code></h4> <code class="qualifiers"></code> <code class="arguments">&amp;REST ARGS</code><code>)</code>  </header> <pre class="docstring">Defines a capture function to fix a symbol binding.

A capture function should take a symbol and return a value to
capture for it, and T as the secondary value if anything should
be captured at all for the kind of binding the function handles.

See *FIXTURE-CAPTURES*</pre> </article> </li><li> <a name="PARACHUTE:DEFINE-FIXTURE-RESTORE"> </a> <article> <header class="macro"> <span class="type">macro</span>  <code>(</code><h4 class="name"><code><a href="#PARACHUTE:DEFINE-FIXTURE-RESTORE">DEFINE-FIXTURE-RESTORE</a></code></h4> <code class="qualifiers"></code> <code class="arguments">&amp;REST ARGS</code><code>)</code>  </header> <pre class="docstring">Defines a restore function to fix a symbol binding.

A restoration function should take a symbol and a value and
make sure to restore the binding it handles to the given value.

See *FIXTURE-RESTORES*</pre> </article> </li><li> <a name="PARACHUTE:DEFINE-TEST"> </a> <article> <header class="macro"> <span class="type">macro</span>  <code>(</code><h4 class="name"><code><a href="#PARACHUTE:DEFINE-TEST">DEFINE-TEST</a></code></h4> <code class="qualifiers"></code> <code class="arguments">&amp;REST ARGS</code><code>)</code>  </header> <pre class="docstring">Defines a test.

NAME can be either a string, a symbol, or a list of a parent name and a name.

BODY ::= KARG* form*
KARG ::= keyword expression

Each karg in the body is used as an initialization argument to the test
instance with the exception of TEST-CLASS, which is used as the class-name
to create a test instance with and defaults to TEST. The values of the
keyword arguments are always passed quoted.

If you set a parent in the NAME, you cannot use the :PARENT karg and vice-
versa. The following initargs are automatically always passed by DEFINE-TEST
and should thus not appear as a karg: :NAME :TESTS :PARENT

You can define child tests within the body of the test if they appear as
&quot;toplevel&quot; forms. They will be taken out of the body forms and emitted
as definition forms after the parent form, with the parent automatically set
appropriately. As such, subtests defined in this manner cannot cause any
effects on the surrounding environment.

Each form within the body will be turned into a separate test function.
This is done so that the tests can be shuffled randomly if the test is not
set as serial. This means that if you need to wrap multiple testers in any
other form, the inner tests cannot be shuffled accordingly. However, you can
use the WITH-SHUFFLING macro.

The karg :COMPILE-AT directs whether each test form should be compiled at
definition time (default, value :COMPILE-TIME) or at test evaluation time
(value :EXECUTE). The latter is achieved by, instead of a straight-up LAMBDA
for each test form, it wraps it in a LAMBDA that calls COMPILE on the source
form.

Note that the dependencies of the test can be a combined by logic operators
of :AND :OR and :NOT. See REFERENCED-DEPENDENCIES for the necessary structure.

See TEST
See FIND-TEST
See REMOVE-TEST
See REFERENCED-DEPENDENCIES</pre> </article> </li><li> <a name="PARACHUTE:FAIL"> </a> <article> <header class="macro"> <span class="type">macro</span>  <code>(</code><h4 class="name"><code><a href="#PARACHUTE:FAIL">FAIL</a></code></h4> <code class="qualifiers"></code> <code class="arguments">&amp;REST ARGS</code><code>)</code>  </header> <pre class="docstring">A tester that succeeds if the form signals an error of the requested type, defaulting to ERROR.</pre> </article> </li><li> <a name="PARACHUTE:FALSE"> </a> <article> <header class="macro"> <span class="type">macro</span>  <code>(</code><h4 class="name"><code><a href="#PARACHUTE:FALSE">FALSE</a></code></h4> <code class="qualifiers"></code> <code class="arguments">&amp;REST ARGS</code><code>)</code>  </header> <pre class="docstring">A tester that succeeds if the form returns NIL as the value.</pre> </article> </li><li> <a name="PARACHUTE:FINISH"> </a> <article> <header class="macro"> <span class="type">macro</span>  <code>(</code><h4 class="name"><code><a href="#PARACHUTE:FINISH">FINISH</a></code></h4> <code class="qualifiers"></code> <code class="arguments">&amp;REST ARGS</code><code>)</code>  </header> <pre class="docstring">A tester that succeeds if the form returns without escaping.</pre> </article> </li><li> <a name="PARACHUTE:IS"> </a> <article> <header class="macro"> <span class="type">macro</span>  <code>(</code><h4 class="name"><code><a href="#PARACHUTE:IS">IS</a></code></h4> <code class="qualifiers"></code> <code class="arguments">&amp;REST ARGS</code><code>)</code>  </header> <pre class="docstring">A tester that succeeds if the value the form returns is equal to the expected value under the given comparator.</pre> </article> </li><li> <a name="PARACHUTE:ISNT"> </a> <article> <header class="macro"> <span class="type">macro</span>  <code>(</code><h4 class="name"><code><a href="#PARACHUTE:ISNT">ISNT</a></code></h4> <code class="qualifiers"></code> <code class="arguments">&amp;REST ARGS</code><code>)</code>  </header> <pre class="docstring">A tester that succeeds if the value the form returns is not equal to the expected value under the given comparator.</pre> </article> </li><li> <a name="PARACHUTE:OF-TYPE"> </a> <article> <header class="macro"> <span class="type">macro</span>  <code>(</code><h4 class="name"><code><a href="#PARACHUTE:OF-TYPE">OF-TYPE</a></code></h4> <code class="qualifiers"></code> <code class="arguments">&amp;REST ARGS</code><code>)</code>  </header> <pre class="docstring">A tester that succeeds if the form returns a value that is of the requested type.</pre> </article> </li><li> <a name="PARACHUTE:SKIP"> </a> <article> <header class="macro"> <span class="type">macro</span>  <code>(</code><h4 class="name"><code><a href="#PARACHUTE:SKIP">SKIP</a></code></h4> <code class="qualifiers"></code> <code class="arguments">&amp;REST ARGS</code><code>)</code>  </header> <pre class="docstring">Skips the tests in the body by avoiding their evaluation and marking their status as :SKIPPED.</pre> </article> </li><li> <a name="PARACHUTE:TRUE"> </a> <article> <header class="macro"> <span class="type">macro</span>  <code>(</code><h4 class="name"><code><a href="#PARACHUTE:TRUE">TRUE</a></code></h4> <code class="qualifiers"></code> <code class="arguments">&amp;REST ARGS</code><code>)</code>  </header> <pre class="docstring">A tester that succeeds if the form returns a non-NIL value.</pre> </article> </li><li> <a name="PARACHUTE:WITH-FIXTURES"> </a> <article> <header class="macro"> <span class="type">macro</span>  <code>(</code><h4 class="name"><code><a href="#PARACHUTE:WITH-FIXTURES">WITH-FIXTURES</a></code></h4> <code class="qualifiers"></code> <code class="arguments">&amp;REST ARGS</code><code>)</code>  </header> <pre class="docstring">Shorthand macro to evaluate the body with the fixtures saved away.

See CALL-WITH-FIXTURES</pre> </article> </li><li> <a name="PARACHUTE:WITH-FORCED-STATUS"> </a> <article> <header class="macro"> <span class="type">macro</span>  <code>(</code><h4 class="name"><code><a href="#PARACHUTE:WITH-FORCED-STATUS">WITH-FORCED-STATUS</a></code></h4> <code class="qualifiers"></code> <code class="arguments">&amp;REST ARGS</code><code>)</code>  </header> <pre class="docstring">Forces the requested status upon the tests in the body without evaluating any value-results.</pre> </article> </li><li> <a name="PARACHUTE:WITH-SHUFFLING"> </a> <article> <header class="macro"> <span class="type">macro</span>  <code>(</code><h4 class="name"><code><a href="#PARACHUTE:WITH-SHUFFLING">WITH-SHUFFLING</a></code></h4> <code class="qualifiers"></code> <code class="arguments">&amp;REST ARGS</code><code>)</code>  </header> <pre class="docstring">Causes each form in the body to be evaluated in random order each time the with-shuffling form is evaluated.

This is done by taking each form, wrapping it in a lambda, shuffling the list of
lambdas, and then funcalling each in the shuffled order.

See SHUFFLE</pre> </article> </li></ul> </li></ul> </article>  </main> </body> </html> 